# Regular Expression Matching
---
### 动态规划

*  令dp[i][j] 表示的状态是s的前i项和p的前j项是否匹配。

#### 转移方程
* 若知道dp[i-1][j-1]的状态，那么有三种情况。
  * s[i]==p[j]or p[j]=='.',dp[i][j]==dp[i-1][j-1]==true;
  * p[j]=='*'，因为\*与前面的字符有关，那么我们比较p[j-1]和s[i]的关系，根据星号前面的字符与s[i]是否相等，再分为两个情况：
    * p[j-1]!=s[i]: 若\*前一个字符匹配不上，则视为\*匹配了0次，跳过这个*，看p[j-2]和s[i]的关系是否匹配，此时dp[i][j]=dp[i][j-2];
    * p[j-1]==s[i] or p[j-1]=='.',表示*前的字符可以与s[i]进行匹配，这种情况下，\* 可能匹配了0次也可能匹配了多次，若匹配0次，dp[i][j]=dp[i][j-2];若匹配多次，需要将s[i]与p重新比较，即dp[i][j]=dp[i-1][j]
  * 其他情况为不匹配，d[i][j]=false;

$$
dp[i][j]=\begin{cases}
dp[i-1][j-1], \ \ \  s[i]==p[j]\ or\ p[j]=='.'\\
dp[i][j]=dp[i][j-2],\ \  p[j]=='*',\ p[j-1]!=s[i]\\
dp[i-1][j]\  or\  dp[i][j-2], \ \ p[j]=='*',\ p[j-1]==s[i]\ or\ p[j-1]=='.'\\
False,\ \ \ else

\end{cases}
$$

